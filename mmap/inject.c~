
#include <errno.h>
#include <sys/mman.h>
#include <sys/types.h>
#include <sys/ptrace.h>
#include <sys/reg.h>
#include <sys/wait.h>
#include <sys/user.h>
#include <sys/stat.h>

#include "inject.h"


/* XXX: no 64 -> 32 bit processes :( */
long inject_scode(pid_t pid,char *sc,size_t size,bit_type type,breakpoint * breaks, int int_count) {

  int status;
  int SPTR = (sizeof(void*));
  long *ptr,*ret,*pc;
  size_t bsize;
  char * buff;
  int i = 0,e=0;

  struct user_regs_struct old_regs;
  struct user_regs_struct regs;

#if  __WORDSIZE == 64
  if(type == BITS64){
    SPTR = 8;
    ret = &regs.rax;
    pc = &old_regs.rip;
  }
#else
  if (type == BITS32){
    SPTR = 4;
    pc = &old_regs.eip;
    ret = &regs.eax;
  }
#endif
  else { die("UNKOWN BIT SIZE"); }

  bsize = size % SPTR == 0 ? size : (size/SPTR+1)*SPTR;
  buff  = malloc(bsize);

  if (ptrace(PTRACE_ATTACH,pid,NULL,NULL) < 0)
    die("ptrace(ATTACH)");

  waitpid(pid, &status, 0);

  printf("[*] saving registers\n");
  if (ptrace(PTRACE_GETREGS,pid,NULL,&old_regs)<0)
    die("ptrace(SAVEREGS)");

  // make place for shellcode...
  printf("[*] making place for shellcode\n");

  ptr = (long*) buff;
  for(i=0;i<bsize;i+=SPTR){
    *ptr = ptrace(PTRACE_PEEKTEXT,pid,*pc+i,NULL);
    ptr++;
  }

  ptr = (long *) sc;
  printf("[+] Copy shellcode... ");
  //copy shellcode
  for(i=0;i<bsize;i+=SPTR)
    if(ptrace(PTRACE_POKETEXT,pid,*pc+i,*ptr++) < 0)
      die("ptrace(POKE_SCODE)");
  printf("done.\n");
  fflush(stdout);
  printf("[+] Executing... ");

  // we will switch to debugger after each syscall
  while(int_count--) {
    if (ptrace(PTRACE_CONT,pid,NULL,NULL) < 0)
      die("ptrace(CONT)") ;

    waitpid(pid,&status,0);
    if(WSTOPSIG(status)  != SIGTRAP)
      die("uncool somthing interupted..");


    if (ptrace(PTRACE_GETREGS,pid,NULL,&regs)<0)
      die("ptrace(SAVEREGS)");

    if(breaks[int_count-1].is_fault(*ret)) {
      e=1;
      break;
    }
  }
  if(e != 0)
    printf("Sth wrong going down..\n");
  else
    printf(" done\n");

  // restore code
  ptr = (long *) buff;
  for(i=0;i<bsize;i+=SPTR)
    if ( ptrace(PTRACE_POKETEXT,pid,*pc+i,*ptr++) <0)
      die("ptrace(RESOTRE)");

  // set rip and regs back
  if (ptrace(PTRACE_SETREGS,pid,NULL,&old_regs)<0)
    die("ptrace(RESOTRE_REGS)");

  if(ptrace(PTRACE_DETACH,pid,NULL,NULL))
    die("ptrace(DETACH)");

  free(buff);

  if(e !=0 ) breaks[int_count-1].report_fault(*ret);
  return *ret;
}
